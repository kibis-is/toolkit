#pragma version 10
#pragma typetrack false

// opensubmarine.contracts.token.ARC200.src.contract.ARC200Token.__algopy_entrypoint_with_init() -> uint64:
main:
    intcblock 1 32 0
    bytecblock 0x151f7c75 0x "balances" 0x80 "name" "symbol" "decimals" "totalSupply" "approvals"
    txn ApplicationID
    bnz main_after_if_else@2
    // src/contract.py:57-58
    // # arc200 state
    // self.name = String()
    bytec 4 // "name"
    bytec_1 // ""
    app_global_put
    // src/contract.py:59
    // self.symbol = String()
    bytec 5 // "symbol"
    bytec_1 // ""
    app_global_put
    // src/contract.py:60
    // self.decimals = UInt64()
    bytec 6 // "decimals"
    intc_2 // 0
    app_global_put
    // src/contract.py:61
    // self.totalSupply = BigUInt()
    bytec 7 // "totalSupply"
    bytec_1 // 0x
    app_global_put

main_after_if_else@2:
    // src/contract.py:135
    // class ARC200Token(ARC200TokenInterface):
    txn NumAppArgs
    bz main_bare_routing@14
    pushbytess 0x657d13ec 0xb6ae1a25 0x84ec13d5 0xec996041 0x82e573c4 0xbbb319f3 0x4a968f8f 0xda7025b9 0xb5422125 // method "arc200_name()byte[32]", method "arc200_symbol()byte[8]", method "arc200_decimals()uint8", method "arc200_totalSupply()uint256", method "arc200_balanceOf(address)uint256", method "arc200_allowance(address,address)uint256", method "arc200_transferFrom(address,address,uint256)bool", method "arc200_transfer(address,uint256)bool", method "arc200_approve(address,uint256)bool"
    txna ApplicationArgs 0
    match main_arc200_name_route@5 main_arc200_symbol_route@6 main_arc200_decimals_route@7 main_arc200_totalSupply_route@8 main_arc200_balanceOf_route@9 main_arc200_allowance_route@10 main_arc200_transferFrom_route@11 main_arc200_transfer_route@12 main_arc200_approve_route@13

main_after_if_else@16:
    // src/contract.py:135
    // class ARC200Token(ARC200TokenInterface):
    intc_2 // 0
    return

main_arc200_approve_route@13:
    // src/contract.py:217
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // src/contract.py:135
    // class ARC200Token(ARC200TokenInterface):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // src/contract.py:217
    // @arc4.abimethod
    callsub arc200_approve
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_arc200_transfer_route@12:
    // src/contract.py:194
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // src/contract.py:135
    // class ARC200Token(ARC200TokenInterface):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // src/contract.py:194
    // @arc4.abimethod
    callsub arc200_transfer
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_arc200_transferFrom_route@11:
    // src/contract.py:176
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // src/contract.py:135
    // class ARC200Token(ARC200TokenInterface):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    // src/contract.py:176
    // @arc4.abimethod
    callsub arc200_transferFrom
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_arc200_allowance_route@10:
    // src/contract.py:163
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // src/contract.py:135
    // class ARC200Token(ARC200TokenInterface):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // src/contract.py:163
    // @arc4.abimethod(readonly=True)
    callsub arc200_allowance
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_arc200_balanceOf_route@9:
    // src/contract.py:155
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // src/contract.py:135
    // class ARC200Token(ARC200TokenInterface):
    txna ApplicationArgs 1
    // src/contract.py:155
    // @arc4.abimethod(readonly=True)
    callsub arc200_balanceOf
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_arc200_totalSupply_route@8:
    // src/contract.py:151
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub arc200_totalSupply
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_arc200_decimals_route@7:
    // src/contract.py:147
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub arc200_decimals
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_arc200_symbol_route@6:
    // src/contract.py:143
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub arc200_symbol
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_arc200_name_route@5:
    // src/contract.py:139
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub arc200_name
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_bare_routing@14:
    // src/contract.py:135
    // class ARC200Token(ARC200TokenInterface):
    txn OnCompletion
    bnz main_after_if_else@16
    txn ApplicationID
    !
    assert // can only call when creating
    intc_0 // 1
    return


// opensubmarine.contracts.token.ARC200.src.contract.ARC200Token.arc200_name() -> bytes:
arc200_name:
    // src/contract.py:141
    // return Bytes32.from_bytes(self.name.bytes)
    intc_2 // 0
    bytec 4 // "name"
    app_global_get_ex
    assert // check self.name exists
    retsub


// opensubmarine.contracts.token.ARC200.src.contract.ARC200Token.arc200_symbol() -> bytes:
arc200_symbol:
    // src/contract.py:145
    // return Bytes8.from_bytes(self.symbol.bytes)
    intc_2 // 0
    bytec 5 // "symbol"
    app_global_get_ex
    assert // check self.symbol exists
    retsub


// opensubmarine.contracts.token.ARC200.src.contract.ARC200Token.arc200_decimals() -> bytes:
arc200_decimals:
    // src/contract.py:149
    // return arc4.UInt8(self.decimals)
    intc_2 // 0
    bytec 6 // "decimals"
    app_global_get_ex
    assert // check self.decimals exists
    itob
    dup
    bitlen
    pushint 8 // 8
    <=
    assert // overflow
    extract 7 1
    retsub


// opensubmarine.contracts.token.ARC200.src.contract.ARC200Token.arc200_totalSupply() -> bytes:
arc200_totalSupply:
    // src/contract.py:153
    // return arc4.UInt256(self.totalSupply)
    intc_2 // 0
    bytec 7 // "totalSupply"
    app_global_get_ex
    assert // check self.totalSupply exists
    dup
    len
    intc_1 // 32
    <=
    assert // overflow
    intc_1 // 32
    bzero
    b|
    retsub


// opensubmarine.contracts.token.ARC200.src.contract.ARC200Token.arc200_balanceOf(account: bytes) -> bytes:
arc200_balanceOf:
    // src/contract.py:155-156
    // @arc4.abimethod(readonly=True)
    // def arc200_balanceOf(self, account: arc4.Address) -> arc4.UInt256:
    proto 1 1
    // src/contract.py:161
    // return self.balances.get(key=account, default=BigUInt(0))
    bytec_2 // "balances"
    frame_dig -1
    concat
    box_get
    bytec_1 // 0x
    cover 2
    select
    // src/contract.py:157
    // return arc4.UInt256(self._balanceOf(account.native))
    dup
    len
    intc_1 // 32
    <=
    assert // overflow
    intc_1 // 32
    bzero
    b|
    retsub


// opensubmarine.contracts.token.ARC200.src.contract.ARC200Token.arc200_allowance(owner: bytes, spender: bytes) -> bytes:
arc200_allowance:
    // src/contract.py:163-166
    // @arc4.abimethod(readonly=True)
    // def arc200_allowance(
    //     self, owner: arc4.Address, spender: arc4.Address
    // ) -> arc4.UInt256:
    proto 2 1
    // src/contract.py:167
    // return arc4.UInt256(self._allowance(owner.native, spender.native))
    frame_dig -2
    frame_dig -1
    callsub _allowance
    dup
    len
    intc_1 // 32
    <=
    assert // overflow
    intc_1 // 32
    bzero
    b|
    retsub


// opensubmarine.contracts.token.ARC200.src.contract.ARC200Token._allowance(owner: bytes, spender: bytes) -> bytes:
_allowance:
    // src/contract.py:169-170
    // @subroutine
    // def _allowance(self, owner: Account, spender: Account) -> BigUInt:
    proto 2 1
    // src/contract.py:172
    // key=op.sha256(owner.bytes + spender.bytes),
    frame_dig -2
    frame_dig -1
    concat
    sha256
    // src/contract.py:171
    // return self.approvals.get(
    bytec 8 // "approvals"
    // src/contract.py:171-174
    // return self.approvals.get(
    //     key=op.sha256(owner.bytes + spender.bytes),
    //     default=BigUInt(0),
    // )
    swap
    concat
    box_get
    // src/contract.py:173
    // default=BigUInt(0),
    bytec_1 // 0x
    // src/contract.py:171-174
    // return self.approvals.get(
    //     key=op.sha256(owner.bytes + spender.bytes),
    //     default=BigUInt(0),
    // )
    cover 2
    select
    retsub


// opensubmarine.contracts.token.ARC200.src.contract.ARC200Token.arc200_transferFrom(sender: bytes, recipient: bytes, amount: bytes) -> bytes:
arc200_transferFrom:
    // src/contract.py:176-179
    // @arc4.abimethod
    // def arc200_transferFrom(
    //     self, sender: arc4.Address, recipient: arc4.Address, amount: arc4.UInt256
    // ) -> arc4.Bool:
    proto 3 1
    // src/contract.py:187
    // spender = Txn.sender
    txn Sender
    // src/contract.py:188
    // spender_allowance = self._allowance(sender, spender)
    frame_dig -3
    dig 1
    callsub _allowance
    // src/contract.py:189
    // assert spender_allowance >= amount, "insufficient approval"
    dup
    frame_dig -1
    b>=
    assert // insufficient approval
    // src/contract.py:190
    // new_spender_allowance = spender_allowance - amount
    frame_dig -1
    b-
    // src/contract.py:191
    // self._approve(sender, spender, new_spender_allowance)
    frame_dig -3
    cover 2
    callsub _approve
    // src/contract.py:192
    // self._transfer(sender, recipient, amount)
    frame_dig -3
    frame_dig -2
    frame_dig -1
    callsub _transfer
    // src/contract.py:181
    // return arc4.Bool(True)
    bytec_3 // 0x80
    retsub


// opensubmarine.contracts.token.ARC200.src.contract.ARC200Token.arc200_transfer(recipient: bytes, amount: bytes) -> bytes:
arc200_transfer:
    // src/contract.py:194-197
    // @arc4.abimethod
    // def arc200_transfer(
    //     self, recipient: arc4.Address, amount: arc4.UInt256
    // ) -> arc4.Bool:
    proto 2 1
    // src/contract.py:198
    // self._transfer(Txn.sender, recipient.native, amount.native)
    txn Sender
    frame_dig -2
    frame_dig -1
    callsub _transfer
    // src/contract.py:199
    // return arc4.Bool(True)
    bytec_3 // 0x80
    retsub


// opensubmarine.contracts.token.ARC200.src.contract.ARC200Token._transfer(sender: bytes, recipient: bytes, amount: bytes) -> void:
_transfer:
    // src/contract.py:201-202
    // @subroutine
    // def _transfer(self, sender: Account, recipient: Account, amount: BigUInt) -> None:
    proto 3 0
    // src/contract.py:161
    // return self.balances.get(key=account, default=BigUInt(0))
    bytec_2 // "balances"
    frame_dig -3
    concat
    dup
    box_get
    bytec_1 // 0x
    cover 2
    select
    dup
    bytec_2 // "balances"
    frame_dig -2
    concat
    dup
    cover 3
    box_get
    bytec_1 // 0x
    cover 2
    select
    cover 2
    // src/contract.py:205
    // assert sender_balance >= amount, "insufficient balance"
    frame_dig -1
    b>=
    assert // insufficient balance
    // src/contract.py:206
    // if sender == recipient:  # prevent self-transfer balance increments
    frame_dig -3
    frame_dig -2
    ==
    bz _transfer_else_body@2
    // src/contract.py:207
    // self.balances[sender] = sender_balance  # current balance or zero
    frame_dig 0
    dup
    box_del
    pop
    swap
    box_put

_transfer_after_if_else@3:
    // src/contract.py:213
    // arc4.Address(sender), arc4.Address(recipient), arc4.UInt256(amount)
    frame_dig -1
    len
    intc_1 // 32
    <=
    assert // overflow
    intc_1 // 32
    bzero
    frame_dig -1
    b|
    // src/contract.py:212-214
    // arc200_Transfer(
    //     arc4.Address(sender), arc4.Address(recipient), arc4.UInt256(amount)
    // )
    frame_dig -3
    frame_dig -2
    concat
    swap
    concat
    // src/contract.py:211-215
    // arc4.emit(
    //     arc200_Transfer(
    //         arc4.Address(sender), arc4.Address(recipient), arc4.UInt256(amount)
    //     )
    // )
    pushbytes 0x7983c35c // method "arc200_Transfer(address,address,uint256)"
    swap
    concat
    log
    retsub

_transfer_else_body@2:
    // src/contract.py:209
    // self.balances[sender] = sender_balance - amount
    frame_dig -1
    b-
    frame_dig 0
    dup
    box_del
    pop
    swap
    box_put
    // src/contract.py:210
    // self.balances[recipient] = recipient_balance + amount
    frame_dig 2
    frame_dig -1
    b+
    frame_dig 1
    dup
    box_del
    pop
    swap
    box_put
    b _transfer_after_if_else@3


// opensubmarine.contracts.token.ARC200.src.contract.ARC200Token.arc200_approve(spender: bytes, amount: bytes) -> bytes:
arc200_approve:
    // src/contract.py:217-218
    // @arc4.abimethod
    // def arc200_approve(self, spender: arc4.Address, amount: arc4.UInt256) -> arc4.Bool:
    proto 2 1
    // src/contract.py:219
    // self._approve(Txn.sender, spender.native, amount.native)
    txn Sender
    frame_dig -2
    frame_dig -1
    callsub _approve
    // src/contract.py:220
    // return arc4.Bool(True)
    bytec_3 // 0x80
    retsub


// opensubmarine.contracts.token.ARC200.src.contract.ARC200Token._approve(owner: bytes, spender: bytes, amount: bytes) -> void:
_approve:
    // src/contract.py:222-223
    // @subroutine
    // def _approve(self, owner: Account, spender: Account, amount: BigUInt) -> None:
    proto 3 0
    // src/contract.py:224
    // self.approvals[op.sha256(owner.bytes + spender.bytes)] = amount
    frame_dig -3
    frame_dig -2
    concat
    dup
    sha256
    bytec 8 // "approvals"
    swap
    concat
    dup
    box_del
    pop
    frame_dig -1
    box_put
    // src/contract.py:227
    // arc4.Address(owner), arc4.Address(spender), arc4.UInt256(amount)
    frame_dig -1
    len
    intc_1 // 32
    <=
    assert // overflow
    intc_1 // 32
    bzero
    frame_dig -1
    b|
    // src/contract.py:226-228
    // arc200_Approval(
    //     arc4.Address(owner), arc4.Address(spender), arc4.UInt256(amount)
    // )
    concat
    // src/contract.py:225-229
    // arc4.emit(
    //     arc200_Approval(
    //         arc4.Address(owner), arc4.Address(spender), arc4.UInt256(amount)
    //     )
    // )
    pushbytes 0x1969f865 // method "arc200_Approval(address,address,uint256)"
    swap
    concat
    log
    retsub
